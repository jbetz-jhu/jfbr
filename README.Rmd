---
output: github_document
---

<!-- README.md is generated from README.Rmd. Please edit that file -->

```{r, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>",
  fig.path = "man/figures/README-",
  out.width = "100%"
)
```

# jfbr

<!-- badges: start -->
[![R-CMD-check](https://github.com/jbetz-jhu/impart/actions/workflows/R-CMD-check.yaml/badge.svg)](https://github.com/jbetz-jhu/impart/actions/workflows/R-CMD-check.yaml)
[![Codecov test coverage](https://codecov.io/gh/jbetz-jhu/jfbr/graph/badge.svg)](https://app.codecov.io/gh/jbetz-jhu/jfbr)
<!-- badges: end -->

The `jfbr` package is meant to test and share miscellaneous functions for quantitative workflows.

## Installation

You can install the development version of jfbr from [GitHub](https://github.com/) with:

```{r Install Impart, eval = FALSE, echo = TRUE}
# install.packages("devtools") # Install devtools if not already installed
devtools::install_github("jbetz-jhu/jfbr")
```


## Examples: Tabulation

Convenience functions have been added for the `table1::table1()` function to make it easier to do different summaries and add hypothesis testing.

```{r Create-Example-Data}
# Create Example Data:
set.seed(12345)
n_obs <- 1000

my_data <-
  data.frame(
    numbers = 1:n_obs,
    continuous = runif(n = n_obs),
    binary = rbinom(n = n_obs, size = 1, prob = 0.5),
    binary_factor =
      factor(
        x = rbinom(n = n_obs, size = 1, prob = 0.5),
        levels = 0:1,
        labels = c("0. No", "1. Yes")
      ),
    categorical = factor(sample(x = 1:4, size = n_obs, replace = TRUE)),
    ordered = ordered(sample(x = 1:4, size = n_obs, replace = TRUE))
  )
```


```{r Load-Packages}
library(jfbr)
library(table1)
```

The default for `table1::table1()` is to produce Mean (SD) and Median [Min, Max].

```{r table1-Defaults}
# table1() defaults
table1(
  x = ~ continuous + numbers | binary_factor,
  data = my_data
)
```

Using the argument `render.continuous = table1_numeric` adds Median [IQR] and [Max, Min]:

```{r table1-table1_numeric-Default}
table1(
  x = ~ continuous + numbers | binary_factor,
  data = my_data,
  render.continuous = table1_numeric
)
```

The arguments `mean_sd`, `median_iqr`, and `range` control which summaries are computed. Quantiles can be added optionally with the `quantiles` argment:

```{r table1-table1_numeric}
# Only Mean/SD
table1(
  x = ~ continuous + numbers | binary_factor,
  data = my_data,
  render.continuous = 
    function(x)
      table1_numeric(
        x = x,
        mean_sd = TRUE, median_iqr = FALSE, range = FALSE,
        quantiles = NULL
      )
)

# Only Mean/SD, 5% and 95% Quantiles
table1(
  x = ~ continuous + numbers | binary_factor,
  data = my_data,
  render.continuous = 
    function(x)
      table1_numeric(
        x = x,
        mean_sd = TRUE, median_iqr = FALSE, range = FALSE,
        quantiles = c(0.05, 0.95)
      )
)
```


Hypothesis tests can be added to `table1` using the `extra.col` argument: there is a worked example of including `t.test` and `chisq.test` in the [table1 documentation](https://cran.r-project.org/web/packages/table1/vignettes/table1-examples.html#example-a-column-of-p-values). The `table1_pvalue` function is a convenience function that allows users to supply their own tests to be computed in `table1`. The defaults include `t.test` and ANOVA omnibus test (via a `lm` and `anova` wrapper) for continuous variables, and `chisq.test` for categorical variables:

```{r table1-pvalues-defaults}
table1::table1(
  x = ~ numbers + continuous + binary + ordered | binary_factor,
  data = my_data,
  overall = FALSE,
  extra.col =
    list("p-value" = table1_pvalue)
)


table1::table1(
  x = ~ numbers + continuous + binary + ordered | categorical,
  data = my_data,
  overall = FALSE,
  extra.col =
    list("p-value" = table1_pvalue)
)
```

Any function that returns an element `p.value` can be passed as an argument, allowing users to customize which tests are performed:

```{r table1-pvalues-custom}
table1::table1(
  x = ~ numbers + continuous + binary + ordered | binary_factor,
  data = my_data,
  overall = FALSE,
  extra.col =
    list("p-value" =
           function(x, value) table1_pvalue(
             x = x,
             variable = variable,
             test_numeric_2_levels = wilcox.test,
             test_numeric_more_than_2_levels = kruskal.test,
             test_categorical_2_levels = fisher.test,
             test_categorical_more_than_2_levels = fisher.test
           )
         )
)
```
